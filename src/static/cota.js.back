(function(d) {
    const cota = d.getElementById('cota')
    if (!cota) { // if this page doesn't contain any element id called 'cota', below code will never run.
        return
    }

    const gravatarMirror = 'https://dn-qiniu-avatar.qbox.me/avatar'
    const serverPath = getServerPathByJSLink()

    const http = { // a simple http query util
        get: (url) => {
            return fetch(url)
        },
        post: (url, data) => {
            return fetch(url, {
                method: 'post',
                headers: {
                    'content-type': 'application/json'
                },
                body: JSON.stringify(data)
            })
        },
        delete: (url, data) => {
            return fetch(url, {
                method: 'delete',
                headers: {
                    'content-type': 'application/json'
                },
                body: JSON.stringify(data)
            })
        }
    }

    let commentPage = 1 // current comment page number
    let commentPageSize = 10 // how many comments will be shown per page

    importCss()

    let commentTo = null // null: to this post; object: to this comment

    // comment-box el
    const commentBox = d.createElement('div')
    commentBox.classList.add('comment-box')
    commentBox.innerHTML = '<textarea class="comment-input"></textarea><div id="comment-btns"><div class="clear"></div></div>'
    cota.prepend(commentBox)
    // user infomation button
    const userInfoButton = d.createElement('a')
    userInfoButton.classList.add('user-info-button')
    userInfoButton.innerHTML = `<img src="${serverPath}/imgs/profile.png" alt="profile" />`
    userInfoButton.addEventListener('click', showPopoverBox)
    // emoji button el
    const emojiButton = d.createElement('a')
    emojiButton.classList.add('emoji')
    emojiButton.innerHTML = `<img src="${serverPath}/imgs/emoticon.png" alt="emoticon" />`
    emojiButton.addEventListener('click', showPopoverBox)
    // submit button el
    const submitButton = d.createElement('a')
    submitButton.classList.add('submit')
    submitButton.innerText = 'Submit'
    submitButton.addEventListener('click', getCommentAndSubmit)
    // cancel reply button el
    const cancelReplyButton = d.createElement('a')
    cancelReplyButton.classList.add('cancel-reply-button')
    cancelReplyButton.innerText = 'Cancel'
    cancelReplyButton.addEventListener('click', cancelReply)
    cancelReplyButton.style.display = 'none' // for default situation, this button will be hide
    // commnet list el
    const commentListEl = d.createElement('ul')
    commentListEl.setAttribute('id', 'comment-list')
    // emoji box
    let emojiSelectBoxStatuts = false
    const emojiSelectBox = d.createElement('div')
    emojiSelectBox.setAttribute('id', 'emoji-select-box')
    emojiSelectBox.innerHTML = '<div class="box-arrow"></div>'
    const emojiSelectBoxContent = d.createElement('div')
    emojiSelectBoxContent.classList.add('box-content')
    emojiSelectBox.prepend(emojiSelectBoxContent)
    // user infomation box
    let userInfoBoxStatuts = false
    const userInfoBox = d.createElement('div')
    userInfoBox.setAttribute('id', 'user-info-box')
    userInfoBox.innerHTML = '<div class="box-arrow"></div>'
    const userInfoBoxContent = d.createElement('div')
    userInfoBoxContent.classList.add('box-content')
    userInfoBox.prepend(userInfoBoxContent)
    d.documentElement.addEventListener('click', hidePopoverBox)
    // inject element
    d.getElementById('comment-btns').prepend(submitButton)
    d.getElementById('comment-btns').prepend(cancelReplyButton)
    d.getElementById('comment-btns').prepend(emojiButton)
    d.getElementById('comment-btns').prepend(userInfoButton)
    cota.append(commentListEl)
    cota.append(emojiSelectBox)
    cota.append(userInfoBox)

    renderCommentList()

    let emojiList = getEmojiFromServer()
    emojiList.forEach(item => {
        emojiSelectBoxContent.append(createEmojiEl(item))
    })

    // import necessary css style
    function importCss() {
        let ifCssAlreadyLoad = false
        Array.from(document.getElementsByTagName('link')).forEach(item => item.href.indexOf('cota.min.css') > -1 ? ifCssAlreadyLoad = true : null)

        if (!ifCssAlreadyLoad) {
            const styleLink = d.createElement('link')
            styleLink.rel = 'stylesheet'
            styleLink.type = 'text/css'
            styleLink.href = `${serverPath}/cota.min.css`
            d.head.append(styleLink)
            console.log('load necessary css of Cota')
        }
    }

    // render main comment box
    function switchCommentBoxPlace(el) {
        el.prepend(commentBox)
    }

    function cancelReply() {
        // hide child comment box
        d.getElementsByClassName('comment-box')[0].remove()

        // show main comment box
        switchCommentBoxPlace(cota)
        cancelReplyButton.style.display = 'none'
        commentTo = null
    }

    // render comment lsit
    function renderCommentList() {
        getCommentFromServer().then(res => {
            const commentList = res.comments

            // render main comment
            commentList.mainComments.forEach(item => {
                const commentListItem = createCommentItem(item)
                commentListEl.append(commentListItem)
            })
            commentList.childComments.forEach(item => {
                const commentListItem = createCommentItem(item, true)
                d.querySelector(`#comment-list-item-${item.parentId} .child`).append(commentListItem)
            })

            if (res.count > commentPageSize) {
                // load more comments button
                const loadMoreCommentsButton = d.createElement('div')
                loadMoreCommentsButton.setAttribute('id', 'load-more')
                loadMoreCommentsButton.innerText = 'Load More'
                loadMoreCommentsButton.addEventListener('click', loadMoreComments)
                cota.append(loadMoreCommentsButton)
            }
        })
    }

    function createCommentItem(item) {
        const commentListItem = d.createElement('li')
        commentListItem.classList.add('comment-list-item')
        commentListItem.setAttribute('id', 'comment-list-item-' + item.id)
        commentListItem.setAttribute('data-id', item.id)
        commentListItem.setAttribute('data-rootid', item.rootId ? item.rootId : item.id)
        commentListItem.innerHTML = `<div class="avatar"><img src="${gravatarMirror}/${md5(item.email)}" alt="${item.nickname}" /></div><ul class="child"></ul>`
        // comment detail el
        const commentDetail = d.createElement('div')
        commentDetail.classList.add('comment-detail')
        commentDetail.addEventListener('mouseenter', function(e) {
            e.stopPropagation()
            e.target.children[0].children[0].style.opacity = '1'
        })
        commentDetail.addEventListener('mouseleave', function(e) {
            e.target.children[0].children[0].style.opacity = '0'
        })
        // comment info el
        const commentInfo = d.createElement('div')
        commentInfo.classList.add('comment-info')
        if (item.website) {
            commentInfo.innerHTML = `<a class="nickname" href="${item.website}">${item.nickname}</a><div class="clear"></div>`
        } else {
            commentInfo.innerHTML = `<span class="nickname">${item.nickname}</span><div class="clear"></div>`
        }
        const reply = d.createElement('a')
        reply.classList.add('reply-comment')
        reply.innerText = 'Reply'
        reply.addEventListener('click', replyCommnet)
        commentDetail.innerHTML = `<div class="comment-content">${item.comment}</div><div class="comment-box-${item.id}"></div>`
        commentInfo.prepend(reply)
        commentDetail.prepend(commentInfo)
        commentListItem.prepend(commentDetail)
        return commentListItem
    }

    // when Reply button clicked
    function replyCommnet(e) {
        // hide main comment box
        d.getElementsByClassName('comment-box')[0].remove()

        // show commnet box below the comment which user wanna reply
        switchCommentBoxPlace(e.target.parentElement.nextElementSibling.nextElementSibling)
        cancelReplyButton.style.display = 'block'
        commentTo = e.target.parentElement.parentElement.parentElement
    }

    // submit comment when user click submit button
    function getCommentAndSubmit(e) {
        const value = e.target.parentElement.previousElementSibling.value
        
        if (value !== '') {
            http.post(`${serverPath}/rest/comment/create`, {
                key: md5(d.location.pathname),
                commentContent: value,
                email: 'wangmaozhu@foxmail.com',
                nickname: 'Matthew',
                title: d.title,
                url: d.location.href,
                parentId: commentTo ? parseInt(commentTo.dataset.id) : 0,
                rootId: commentTo ? parseInt(commentTo.dataset.rootid) : 0
            }).then(res => res.json()).then(res => {
                const commentListItem = createCommentItem({
                    id: res.response.id,
                    postId: res.response.postId,
                    parentId: res.response.parentId,
                    rootId: res.response.rootId,
                    email: res.response.email,
                    website: res.response.website,
                    nickname: res.response.nickname,
                    comment: res.response.comment
                })

                if (res.success) {
                    notify('Submit comment successfully!', 'success')
                    if (commentTo === null) {
                        commentListEl.prepend(commentListItem)
                    } else {
                        commentTo.children[2].append(commentListItem)
                    }
                    
                    if (e.target.previousElementSibling.style.display === 'block') {
                        e.target.previousElementSibling.click()
                    }
                    e.target.parentElement.previousElementSibling.value = ''
                } else {
                    notify('Submit comment failed!', 'failed')
                }
            }).catch(() => notify('Submit comment failed!', 'failed'))
        } else {
            notify('Comment cannot be empty!', 'failed')
        }
    }

    function showPopoverBox(e) {
        let target = e.target
        let actualTarget = null

        if (target.className === 'emoji' || target.alt === 'emoticon') {
            actualTarget = emojiSelectBox
            emojiSelectBoxStatuts = true
        } else if (target.className === 'user-info-button' || target.alt === 'profile') {
            actualTarget = userInfoBox
            userInfoBoxStatuts = true
        }

        target.alt ? target = target.parentElement : null
        const position = getElementPagePosition(target)
        const left = (position.x + ((target.offsetWidth) / 2) - 44)

        actualTarget.style.cssText = `top: ${position.y + emojiButton.offsetHeight + 9}px; left: ${left}px`
        actualTarget.className = 'show-box'
    }

    function hidePopoverBox(e) {
        if (emojiSelectBoxStatuts && e.target.closest('#emoji-select-box') === null && e.target.className !== 'emoji' && e.target.alt !== 'emoticon') {
            emojiSelectBox.className = 'hide-box'
        } 
        if (userInfoBoxStatuts && e.target.closest('#user-info-box') === null && e.target.className !== 'user-info-button' && e.target.alt !== 'profile') {
            userInfoBox.className = 'hide-box'
        }
    }

    function createEmojiEl(emoji) {
        const tEmoji = d.createElement('a')
        tEmoji.innerText = emoji
        tEmoji.addEventListener('click', insertEmojiToTextarea)
        return tEmoji
    }

    function insertEmojiToTextarea(e) {
        const content = e.target.innerText
        const inputBox = commentBox.children[0]
        inputBox.value = inputBox.value + content
    }

    function getElementPagePosition(element){
        let actualLeft = element.offsetLeft;
        let current = element.offsetParent;
        while (current !== null) {
            actualLeft += current.offsetLeft;
            current = current.offsetParent;
        }
        let actualTop = element.offsetTop;
        current = element.offsetParent;
        while (current !== null) {
            actualTop += (current.offsetTop+current.clientTop);
            current = current.offsetParent;
        }
        return { x: actualLeft, y: actualTop }
    }

    // custom notification component
    function notify(msg, type = 'info', delay = 3000) {
        let notification = null
        const existNotification = d.getElementById('notification')
        if (!existNotification) {
            const noti = d.createElement('div')
            noti.setAttribute('id', 'notification')
            noti.classList.add('show')
            noti.innerHTML = `<div class="icon"><img src="${serverPath}/imgs/${type}.png" alt="${type}" /></div><div class="content">${msg}</div>`
            notification = noti
            cota.append(noti)
        } else {
            existNotification.children[0].children[0].src = `${serverPath}/imgs/${type}.png`
            existNotification.children[0].children[0].alt = type
            existNotification.children[1].innerText = msg
            existNotification.className = 'show'
            notification = existNotification
        }

        setTimeout(() => {
            notification.className = 'hide'
        }, delay)
    }

    // fetch comment list from server
    function getCommentFromServer() {
        return http.get(`${serverPath}/rest/comments/${md5(d.location.pathname)}/${commentPage}/${commentPageSize}`).then(res => res.json()).then(res => {
            if (res.success) {
                return {
                    comments: res.response.comments,
                    count: res.response.count
                }
            }
        })
    }

    function loadMoreComments(e) {
        
    }

    function getEmojiFromServer() {
        return ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„']
    }

    function getServerPathByJSLink() {
        const schema = Array.from(document.scripts).find(item => item.src.indexOf('cota.min.js') > -1).src.match(/^(\S*):\/\//)[1]
        const server = Array.from(document.scripts).find(item => item.src.indexOf('cota.min.js') > -1).src.match(/[https|http]:\/\/(\S*)\//)[1]
        return `${schema}://${server}`
    }
})(document)